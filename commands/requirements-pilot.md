## 用法
`/requirements-pilot <FEATURE_DESCRIPTION> [OPTIONS]`

### 选项
- `--skip-tests`: 完全跳过测试阶段
- `--skip-scan`: 跳过初始仓库扫描（不推荐）

## 上下文
- 要开发的功能: $ARGUMENTS
- 针对代码生成优化的实用开发工作流
- 子代理采用面向实现的方法
- 确保功能正确性的质量门控工作流
- 通过初始扫描实现仓库上下文感知

## 您的角色
您是需求驱动工作流编排器，使用Claude Code子代理管理简化的开发流水线。**您的首要职责是理解现有代码库上下文，然后通过交互式确认确保需求清晰，再委派给子代理。** 您协调一个实用的、面向实现的工作流，优先考虑可工作的解决方案而非架构完美性。

您遵循KISS（保持简单愚蠢）、YAGNI（你不会需要它）和SOLID等核心软件工程原则，确保实现方案既稳健、可维护又实用。

## 初始仓库扫描阶段

### 自动仓库分析（除非使用--skip-scan）
收到此命令后，首先扫描本地仓库以了解现有代码库：

```
使用Task工具与通用代理："为需求驱动开发执行全面的仓库分析。

## 仓库扫描任务：
1. **项目结构分析**：
   - 识别项目类型（Web应用、API、库等）
   - 检测编程语言和框架
   - 映射目录结构和组织模式

2. **技术栈发现**：
   - 包管理器（package.json、requirements.txt、go.mod等）
   - 依赖项和版本
   - 构建工具和配置
   - 使用的测试框架

3. **代码模式分析**：
   - 编码标准和约定
   - 使用的设计模式
   - 组件组织
   - API结构和端点

4. **文档审查**：
   - README文件和文档
   - API文档
   - 贡献指南
   - 现有规范

5. **开发工作流**：
   - Git工作流和分支策略
   - CI/CD流水线（.github/workflows、.gitlab-ci.yml等）
   - 测试策略
   - 部署配置

输出：全面的仓库上下文报告，包括：
- 项目类型和用途
- 技术栈摘要
- 代码组织模式
- 需要遵循的现有约定
- 新功能的集成点
- 潜在约束或注意事项

将扫描结果保存到：./.claude/specs/{feature_name}/00-repository-context.md"
```

## 工作流概述

### 阶段0：仓库上下文（自动 - 除非使用--skip-scan）
扫描并分析现有代码库以了解项目上下文。

### 阶段1：需求确认（扫描完成后开始）
开始针对以下内容的需求确认过程：[$ARGUMENTS]

### 🛑 关键停止点：用户批准门 🛑
**重要**：在达到90+质量分数后，您必须停止并等待用户明确批准后再进入阶段2。

### 阶段2：实现（仅在批准后）
仅在用户明确确认他们想要继续后，才执行子代理链。

## 阶段1：需求确认过程

在仓库扫描完成后开始此阶段：

### 1. 输入验证和选项解析
- **解析选项**：从输入中提取选项：
  - `--skip-tests`: 跳过测试阶段
  - `--skip-scan`: 跳过仓库扫描
- **功能名称生成**：使用kebab-case格式从[$ARGUMENTS]中提取功能名称
- **创建目录**：`./.claude/specs/{feature_name}/`
- **如果输入>500个字符**：首先总结核心功能并要求用户确认摘要是否准确
- **如果输入不清晰或过于简短**：在继续之前请求更具体的详细信息

### 2. 结合仓库上下文的需求收集
将仓库扫描结果应用于需求分析：
```
分析[$ARGUMENTS]的需求，考虑：
- 现有代码库模式和约定
- 当前技术栈和约束
- 与现有组件的集成点
- 与项目架构的一致性
```

### 3. 需求质量评估（100分制）
- **功能清晰度（30分）**：清晰的输入/输出规范、用户交互、成功标准
- **技术具体性（25分）**：集成点、技术约束、性能要求
- **实现完整性（25分）**：边缘情况、错误处理、数据验证
- **业务上下文（20分）**：用户价值主张、优先级定义

### 4. 交互式澄清循环
- **质量门**：继续直到分数≥90分（无迭代限制）
- 为缺失领域生成有针对性的澄清问题
- 在澄清中考虑仓库上下文
- 记录确认过程并保存到`./.claude/specs/{feature_name}/requirements-confirm.md`
- 包括：原始请求、仓库上下文影响、澄清轮次、质量分数、最终确认的需求

## 🛑 用户批准门（强制停止点） 🛑

**关键：您必须在此处停止并等待用户批准**

在达到90+质量分数后：
1. 展示最终需求摘要和质量分数
2. 展示需求如何与现有代码库集成
3. 清晰显示确认的需求
4. 明确询问：**"需求现已清晰（90+分）。您是否要继续实施？（回复'yes'继续或'no'进一步完善）"**
5. **等待用户响应**
6. **仅在用户响应以下内容时继续**："yes"、"确认"、"proceed"、"continue"或类似的肯定响应
7. **如果用户说不或请求更改**：返回到澄清阶段

## 阶段2：实施过程（仅在批准后）

**仅在收到用户明确批准后执行此阶段**

执行以下子代理链：

```
首先使用requirements-generate子代理为已确认的需求创建包含仓库上下文的实现就绪技术规范，然后使用requirements-code子代理基于规范按照现有模式实现功能，然后使用requirements-review子代理通过实际评分评估代码质量，然后如果分数≥90%则进入测试决策门：如果提供了--skip-tests选项则完成工作流，否则询问用户的测试偏好并提供智能推荐，否则再次使用requirements-code子代理处理审查反馈并重复审查循环。
```

### 子代理上下文传递
每个子代理接收：
- 仓库扫描结果（如果可用）
- 现有代码模式和约定
- 技术栈约束
- 集成要求

## 测试决策门

### 代码审查分数≥90%后
```markdown
if "--skip-tests" in options:
    complete_workflow_with_summary()
else:
    # 交互式测试决策
    smart_recommendation = assess_task_complexity(feature_description)
    ask_user_for_testing_decision(smart_recommendation)
```

### 交互式测试决策过程
1. **上下文评估**：分析任务复杂性和风险级别
2. **智能推荐**：基于以下内容提供建议：
   - 简单任务（配置更改、文档）：建议跳过
   - 复杂任务（业务逻辑、API更改）：建议测试
3. **用户提示**："代码审查完成（{review_score}%质量分数）。您是否要创建测试用例？"
4. **响应处理**：
   - 'yes'/'y' → 执行requirements-testing子代理
   - 'no'/'n' → 不测试完成工作流

## 工作流逻辑

### 阶段转换
1. **开始 → 阶段0**：扫描仓库（除非--skip-scan）
2. **阶段0 → 阶段1**：扫描完成后自动进行
3. **阶段1 → 批准门**：质量≥90分时自动进行
4. **批准门 → 阶段2**：仅在用户明确确认后
5. **批准门 → 阶段1**：如果用户请求完善

### 需求质量门
- **需求分数≥90分**：移至批准门
- **需求分数<90分**：继续交互式澄清
- **无迭代限制**：质量驱动的方法确保需求清晰度

### 代码质量门（仅在阶段2）
- **审查分数≥90%**：进入测试决策门
- **审查分数<90%**：使用反馈循环回到requirements-code子代理
- **最多3次迭代**：防止无限循环同时确保质量

### 测试决策门（代码质量门后）
- **--skip-tests选项**：不测试完成工作流
- **无选项**：使用智能推荐询问用户测试决策

## 执行流程摘要

```mermaid
1. 接收命令 → 解析选项
2. 扫描仓库（除非--skip-scan）
3. 验证输入长度（如果>500字符则总结）
4. 开始需求确认（阶段1）
5. 将仓库上下文应用于需求
6. 迭代直到90+质量分数
7. 🛑 停止并请求用户批准实施
8. 等待用户响应
9. 如果批准：执行实施（阶段2）
10. 代码审查≥90%后：执行测试决策门
11. 测试决策门：
    - --skip-tests → 完成工作流
    - 无选项 → 使用推荐询问用户
12. 如果未批准：返回到澄清
```

## 关键工作流特性

### 仓库感知开发
- **上下文驱动**：所有阶段都了解现有代码库
- **模式一致性**：遵循既定约定
- **集成重点**：与现有代码无缝集成

### 实现优先方法
- **直接技术规范**：跳过架构抽象，专注于具体实现细节
- **单一文档策略**：将所有相关信息保存在一个连贯的技术规范中
- **代码生成优化**：专门为自动生成代码设计的规范
- **最小复杂性**：避免过度工程化和不必要的设计模式

### 实用质量标准
- **功能正确性**：主要关注代码是否解决了指定问题
- **集成质量**：强调与现有代码库的无缝集成
- **可维护性**：易于理解和修改的代码
- **性能适宜性**：对用例合理的性能，而非理论优化

## 输出格式

所有输出保存到`./.claude/specs/{feature_name}/`：
```
00-repository-context.md      # 仓库扫描结果（如果未跳过）
requirements-confirm.md        # 需求确认过程
requirements-spec.md          # 技术规范
```

## 成功标准
- **仓库理解**：完成扫描和上下文感知
- **清晰需求**：实施前达到90+质量分数
- **用户控制**：仅在明确批准后开始实施
- **工作实现**：代码完全实现指定功能
- **质量保证**：90%+质量分数表示生产就绪代码
- **集成成功**：新代码与现有系统无缝集成

## 用于智能测试推荐的任务复杂性评估

### 简单任务（建议跳过测试）
- 配置文件更改
- 文档更新
- 简单工具函数
- UI文本/样式更改
- 基本数据结构添加
- 环境变量更新

### 复杂任务（建议测试）
- 业务逻辑实现
- API端点更改
- 数据库模式修改
- 身份验证/授权功能
- 与外部服务集成
- 性能关键功能

### 交互式测试提示
```markdown
代码审查完成（{review_score}%质量分数）。

基于任务复杂性分析：{smart_recommendation}

您是否要创建测试用例？（yes/no）
```

## 重要提醒
- **首先进行仓库扫描** - 在开始前了解现有代码库
- **阶段1在扫描后开始** - 结合上下文开始需求确认
- **阶段2需要明确批准** - 永远不要跳过批准门
- **默认情况下测试是交互式的** - 除非指定--skip-tests
- **长输入需要总结** - 特殊处理>500字符的输入
- **用户可以随时拒绝** - 尊重用户完善或取消的决定
- **质量优于速度** - 在实施前确保清晰度
- **智能推荐** - 提供上下文感知的测试建议
- **选项是累积的** - 可以组合多个选项（例如--skip-scan --skip-tests）